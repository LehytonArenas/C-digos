---
title: "Determinantes del Ingreso"
author: "Lehyton Arenas"
date: "12/21/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Resumen de estadísticos descriptivos
En la siguiente tabla se encuentra el resúmen estadístico para el año 2017. La tabla contiene en las columnas los estadísticos de: cuantil al 25%, mediana, cuantil al 75%, media y desviación estandar; mientras que en cada fila se encuentra cada una de las variables disponibles en la data construida. Evidentemente todas estas variables son cuantitativas, algunas de orden dummy y otras de orden continuo. Tal y como se puede evidenciar a continuación.
```{r Descriptivos con Survey Package, echo=FALSE}
# Evitemos la notación científica:
options(scipen=999)

# Librerias
library(readxl)
library(tidyverse)
library(plyr); library(dplyr)
library(survey)
library(jtools)
library(stargazer)

# Data 2017
DataAnio_2017 <- read_excel("/Volumes/Respaldo/Google Drive-Actualizado/Ecsim/Proyecto Agosto/3_Entregables Lehyton/Data/DataAnio_2017_v3.xlsx")

# Adultos
Adultos_2017 <- DataAnio_2017 %>% 
  filter(Edad>=18)

# dividimos el Fex en 12:
Adultos_2017 <- Adultos_2017 %>% 
  mutate(FExp=fex_c_2011/12) %>% 
  select(.,-c(fex_c_2011))

# Aplicamos el Survey:
AdutosSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=Adultos_2017)

# Medias: Aplicamos svymean a cada variable.
# Se hace una a una, de lo contrario los valores cambiarán debido a la eliminación causada por na.rm=T
# Haremos tres vbles a modo de prueba para 2017, en caso de más se puede intentar un FOR.
# Se apilan en un DF y se eliminan Means individuales
MeanSexo <- data.frame(svymean(~Sexo, AdutosSvy_2017, na.rm=T)) %>% 
  select(.,c("mean"))
MeanEdad <- data.frame(svymean(~Edad, AdutosSvy_2017, na.rm=T)) %>% 
  select(.,c("mean"))
MeanNivelEducativo <- data.frame(svymean(~NivelEducativo, AdutosSvy_2017,
                                         na.rm=T)) %>% 
  select(.,c("mean"))

Means_2017 <- rbind(MeanSexo,MeanEdad,MeanNivelEducativo) %>% 
  dplyr::rename(.,Mean=mean)
rm(MeanSexo,MeanEdad,MeanNivelEducativo)

# SD: Se aplica Svysd a cada variable.
# Se aplica el mismo procedimiento que en Means explicado anteriormente
SD_Sexo <- svysd(~Sexo,design = AdutosSvy_2017, na.rm = TRUE)
SD_Edad <- svysd(~Edad,design = AdutosSvy_2017, na.rm = TRUE)
SD_NivelEducativo <- svysd(~NivelEducativo,design = AdutosSvy_2017, 
                           na.rm = TRUE)
SD_2017 <- data.frame(rbind(SD_Sexo,SD_Edad,SD_NivelEducativo)) %>% 
  dplyr::rename(.,SD = "Sexo")
rm(SD_Sexo,SD_Edad,SD_NivelEducativo)

# Cuartiles: Se encuentran con svyquantile
# Se aplica el mismo procedimiento que en Means explicado anteriormente
Q_Sexo <- data.frame(svyquantile(~Sexo, design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_Edad <- data.frame(svyquantile(~Edad, design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_NivelEducativo <- data.frame(svyquantile(~NivelEducativo, 
                                           design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_2017 <- data.frame(rbind(Q_Sexo,Q_Edad,Q_NivelEducativo))
rm(Q_Sexo,Q_Edad,Q_NivelEducativo)

# Se apila todo en un solo DF y se eliminan los anteriores pasos
Descriptivos_2017 <- cbind(Q_2017,Means_2017,SD_2017)
rm(Q_2017,Means_2017,SD_2017)

knitr::kable(
  Descriptivos_2017,
  caption = "Resumen estadístico Año 2017"
)
```

## Estadísticas por ciudad
La data recopilada se ha agrupado por ciudad y se han encontrado algunos resultados que vale la pena exponer. Es interesante observar como el ingreso medio de la población denominada Autoempleada es sustancialmente inferior a los ingresos medios de la ciudad; mientras que la población denominada Generadores de empleo exponen ingresos medios sustancialmente superiores.
```{r Estadísticas por Ciudad con Survey, echo=FALSE}
# Se puede mejorar con los subgrupos explicados en el Seminario (Justo antes de modelos)
# Solo se hace para Medellin en 2017.
# En caso de mas se puede crear una función.

# Primero debemos filtrar por ciudad: Población Gral, Autoempleados y Generadores.
# Aplicamos el survey correspondiente
Medellin_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin")
MedellinSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=Medellin_2017)

MedellinAutoem_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin"& Autoempleado==1)
MedellinAutoSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=MedellinAutoem_2017)

MedellinGener_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin"& GeneradorEmpleo==1)
MedellinGenerSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=MedellinGener_2017)

# Se sacan las medias correspondientes, recordar que es una a una.
# Se apilan en un solo DF.
# se eliminan intermedios
Medellin_MeanEduca <- data.frame(svymean(~AniosEscolaridad, 
                                         MedellinSvy_2017, na.rm=T)) %>%
                          select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngreso <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngAuto <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinAutoSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngGener <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinGenerSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_Means <- data.frame(t(rbind(Medellin_MeanEduca,
                                            Medellin_MeanIngreso,
                                 Medellin_MeanIngAuto,
                                 Medellin_MeanIngGener))) %>% 
  dplyr::rename(.,"Años de escolaridad"="AniosEscolaridad",
                "Ingreso"="IngresoLaboral_Mes",
                "Ingreso de Autoempleadores"="IngresoLaboral_Mes1",
                "Ingreso de Generadores"="IngresoLaboral_Mes2")

rm(Medellin_2017,MedellinSvy_2017,MedellinAutoem_2017,MedellinAutoSvy_2017,
   MedellinGener_2017,MedellinGenerSvy_2017,Medellin_MeanEduca,
   Medellin_MeanIngreso,Medellin_MeanIngAuto,Medellin_MeanIngGener)

# Creamos la tabla.
knitr::kable(
  Medellin_Means,
  caption = "Estadísticas Ciudad Año 2017"
)
```

## Modelos

Recordemos que el modelo se desarrollará en tres etapas:

Etapa 1: 
Esta etapa busca encontrar la probabilidad de que un individuo sea Generador de empleo o Autoempleado. Por lo cual se harán dos estimaciones.
Variable dependiente: Se usarán las varibles dicotomicas de Generador de empleo y Autoempleado, respectivamente.
variables independientes: Se emplearán aquí las características socioeconómicas. Especificamente se usarán las variables de Ciudad impuestos, Ciudad apoyo al emprendimiento, Ciudad exportación de tecnologías.
Controles: Se emplearán aquí las características institucionales (o individules?). Estas son: Sexo, Edad, Posesión de TICs, Carga económica, Ciudad: PIB PC, y, Ciudad: Desempleo

Etapa 2: Aquí se estimará el ingreso del individuo empresario
Variable dependiente: Ingreso del individuo empresario.
Variables independientes: La probabilidad estimada en la etapa1, el sector económico, nivel educativo, experiencia potencial.
Controles: Se usarán aquí características institucionales. Es decir variables asociadas con el capital financiero, Ciudad:tamaño(población), Ciudad: tasa de delicuencia.
```{r Etapas 1y2 Simultaneas, echo=FALSE}
# Traemos la función.
tspls <- function(formula1, formula2, data) {
    # The Continous model
    mf1 <- model.frame(formula1, data)
    y1 <- model.response(mf1)
    x1 <- model.matrix(attr(mf1, "terms"), mf1)

    # The dicontionous model
    mf2 <- model.frame(formula2, data)
    y2 <- model.response(mf2)
    x2 <- model.matrix(attr(mf2, "terms"), mf2)

    # The matrix of all the exogenous variables
    X <- cbind(x1, x2)
    X <- X[, unique(colnames(X))]

    J1 <- matrix(0, nrow = ncol(X), ncol = ncol(x1))
    J2 <- matrix(0, nrow = ncol(X), ncol = ncol(x2))
    for (i in 1:ncol(x1)) J1[match(colnames(x1)[i], colnames(X)), i] <- 1
    for (i in 1:ncol(x2)) J2[match(colnames(x2)[i], colnames(X)), i] <- 1

    # Step 1:
    cat("\n\tNOW THE FIRST STAGE REGRESSION")
    m1 <- lm(y1 ~ X - 1)
    m2 <- glm(y2 ~ X - 1, family = binomial(link = "probit"))
    print(summary(m1))
    print(summary(m2))

    yhat1 <- m1$fitted.values
    yhat2 <- X %*% coef(m2)

    PI1 <- m1$coefficients
    PI2 <- m2$coefficients
    V0 <- vcov(m2)
    sigma1sq <- sum(m1$residuals ^ 2) / m1$df.residual
    sigma12 <- 1 / length(y2) * sum(y2 * m1$residuals / dnorm(yhat2))

    # Step 2:
    cat("\n\tNOW THE SECOND STAGE REGRESSION WITH INSTRUMENTS")

    m1 <- lm(y1 ~ yhat2 + x1 - 1)
    m2 <- glm(y2 ~ yhat1 + x2 - 1, family = binomial(link = "probit"))
    sm1 <- summary(m1)
    sm2 <- summary(m2)
    print(sm1)
    print(sm2)

    # Step  3:
    cat("\tNOW THE SECOND STAGE REGRESSION WITH CORRECTED STANDARD ERRORS\n\n")
    gamma1 <- m1$coefficients[1]
    gamma2 <- m2$coefficients[1]

    cc <- sigma1sq - 2 * gamma1 * sigma12
    dd <- gamma2 ^ 2 * sigma1sq - 2 * gamma2 * sigma12
    H <- cbind(PI2, J1)
    G <- cbind(PI1, J2)

    XX <- crossprod(X)                          # X'X
    HXXH <- solve(t(H) %*% XX %*% H)            # (H'X'XH)^(-1)
    HXXVXXH <- t(H) %*% XX %*% V0 %*% XX %*% H  # H'X'V0X'XH
    Valpha1 <- cc * HXXH + gamma1 ^ 2 * HXXH %*% HXXVXXH %*% HXXH

    GV <- t(G) %*% solve(V0)    # G'V0^(-1)
    GVG <- solve(GV %*% G)      # (G'V0^(-1)G)^(-1)
    Valpha2 <- GVG + dd * GVG %*% GV %*% solve(XX) %*% solve(V0) %*% G %*% GVG

    ans1 <- coef(sm1)
    ans2 <- coef(sm2)

    ans1[,2] <- sqrt(diag(Valpha1))
    ans2[,2] <- sqrt(diag(Valpha2))
    ans1[,3] <- ans1[,1] / ans1[,2]
    ans2[,3] <- ans2[,1] / ans2[,2]
    ans1[,4] <- 2 * pt(abs(ans1[,3]), m1$df.residual, lower.tail = FALSE)
    ans2[,4] <- 2 * pnorm(abs(ans2[,3]), lower.tail = FALSE)

    cat("Continuous:\n")
    print(ans1)
    cat("Dichotomous:\n")
    print(ans2)
}

# Para 2017:
# Creamos la data seleccionando las variables de interés y eliminando na.
# Variables Etapa 1:
# Dependiente: Autoempleado, GeneradorEmpleo
# Independientes: Ciudad Impuestos (AutonomiaFiscal_2018_base2017,CapacidadRecaudo_2018_base2017), Ciudad Apoyo al emprendimiento (FacilidadEmpresa_2018,ImpuestosEmpresa_2018), Ciudad exportación tecnologías (ComplejidadProductiva_2018, DiversifCanasta_2018_base2018).
# Controles: Sexo, Edad, Posesión TICS(PosesionComputador,PosesionInternet), CargaEconomica, Ciudad PIB PC(PIB_PC2017_Dane), Ciudad Desempleo(Desempleo_2018,Desempleo_2017_Dane)

# Variables Etapa 2:
# Dependiente: IngresoLaboral_Mes
# Independientes: Dummies de Sector económico
# Controles: Educación (NivelEducativo,AniosEscolaridad); ExperienciaPotencial; K Financiero(CapFinanciero_Mes,CapFinanciero_Anio); Ciudad Tamaño (Poblacion_2017_Dane); Ciudad delincuencia (Homicidios_2018_base2018,Hurtos_2018_base2018,Extorsion_2018_base2018,EficJusticia_2018_base2017,ProducJueces_2018_base2017)

# Formula original:
#tspls(continua~variable1+variable2,
 #    dicotomica~variable3+variable44,
  #  data = AdutosSvy_2017)

# Prueba1:
# Modelo continuo: Ingreso vs anios escolaridad.
# Modelo discreto: Autoempleado vs Autonomia Fiscal
tspls_Prueba1 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes","AniosEscolaridad","Autoempleado",
                  "AutonomiaFiscal_2018_base2017")) %>% 
  drop_na(.)

# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad,
     Autoempleado~AutonomiaFiscal_2018_base2017,
    data = tspls_Prueba1)

# Prueba 2:
# Modelo continuo: Ingreso vs nivel educativo
# Modelo discreto: Autoempleado vs Autonomia fiscal

tspls_Prueba2 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "NivelEducativo",
                  "AutonomiaFiscal_2018_base2017")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~NivelEducativo,
     Autoempleado~AutonomiaFiscal_2018_base2017,
    data = tspls_Prueba2)

# Prueba 3:
tspls_Prueba3 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "NivelEducativo",
                  "AutonomiaFiscal_2018_base2017")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad+NivelEducativo,
     Autoempleado~AutonomiaFiscal_2018_base2017,
    data = tspls_Prueba3)

# Prueba 4:
#  Incluir Ciudad Apoyo al emprendimiento

tspls_Prueba4 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "AutonomiaFiscal_2018_base2017",
                  "FacilidadEmpresa_2018")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad,
     Autoempleado~AutonomiaFiscal_2018_base2017+FacilidadEmpresa_2018,
    data = tspls_Prueba4)

# Prueba 5:
#  Incluir Ciudad Apoyo al emprendimiento
tspls_Prueba5 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "AutonomiaFiscal_2018_base2017",
                  "ImpuestosEmpresa_2018")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad,
     Autoempleado~AutonomiaFiscal_2018_base2017+ImpuestosEmpresa_2018,
    data = tspls_Prueba5)

# Prueba 6
#  Incluir Ciudad Apoyo al emprendimiento
tspls_Prueba6 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "NivelEducativo",
                  "AutonomiaFiscal_2018_base2017",
                  "ImpuestosEmpresa_2018")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~NivelEducativo,
     Autoempleado~AutonomiaFiscal_2018_base2017+ImpuestosEmpresa_2018,
    data = tspls_Prueba6)

# Prueba 7
#  Incluir Experiencia Poptencial
tspls_Prueba7 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "AutonomiaFiscal_2018_base2017",
                  "FacilidadEmpresa_2018",
                  "ExperienciaPotencial")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad+ExperienciaPotencial,
     Autoempleado~AutonomiaFiscal_2018_base2017+FacilidadEmpresa_2018,
    data = tspls_Prueba7)

# Prueba 8
#  Incluir Experiencia Poptencial
tspls_Prueba8 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "AutonomiaFiscal_2018_base2017",
                  "ImpuestosEmpresa_2018",
                  "ExperienciaPotencial")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad+ExperienciaPotencial,
     Autoempleado~AutonomiaFiscal_2018_base2017+ImpuestosEmpresa_2018,
    data = tspls_Prueba8)

# Prueba 9
#  Incluir Experiencia Poptencial
tspls_Prueba9 <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "NivelEducativo",
                  "AutonomiaFiscal_2018_base2017",
                  "ImpuestosEmpresa_2018",
                  "ExperienciaPotencial")) %>%
  drop_na(.)
# Aplicamos el modelo:
tspls(IngresoLaboral_Mes~NivelEducativo+ExperienciaPotencial,
     Autoempleado~AutonomiaFiscal_2018_base2017+ImpuestosEmpresa_2018,
    data = tspls_Prueba9)

# Prueba con el for:
# Definimos los vectores de las vbles independientes
IV_Educacion <- c("AniosEscolaridad","NivelEducativo")
IV_Impuestos <- c("AutonomiaFiscal_2018_base2017","CapacidadRecaudo_2018_base2017")

t=0
for (i in IV_Educacion) {
  for (j in IV_Impuestos) {
    tspls_PruebaFor <- Adultos_2017 %>%
      dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  i,j)) %>%
      drop_na(.)
    
    funp <- as.formula(paste("IngresoLaboral_Mes",i,sep = "~"))
    funp2 <- as.formula(paste("Autoempleado",j,sep = "~"))
    try(tspls(funp,
          funp2,
          data = tspls_PruebaFor))
    t=t+1
    print(c(i,j))
    }
}
print(t)

# Paso1: Filtramos info.
tspls_PruebaFor <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  "AniosEscolaridad",
                  "NivelEducativo",
                  "AutonomiaFiscal_2018_base2017",
                  "CapacidadRecaudo_2018_base2017")) %>% 
  drop_na(.)

# Joe:
tspls_PruebaFor <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes",
                  "Autoempleado",
                  i,j)) %>% 
  drop_na(.)
# Paso 2: Aplicamos el modelo:
tspls(IngresoLaboral_Mes~AniosEscolaridad,
     Autoempleado~AutonomiaFiscal_2018_base2017,
    data = tspls_Prueba1)

```
Etapa 3: Aquí se estimará el ingreso del hogar del empresario.
Variable dependiente: Ingreso del hogar del individuo empresario.
Variable independiente: Se usará el ingreso del individuo empresario estimado en la etapa 1.
Controles: Se usarán controles por familias. Específicamente variables de Parentesco con Jefe de hogar, Estado Civil, Situación laboral, Transferencias o subsidios, posesión de viviendda, # de niños menores a 14 años, # Personas en el hogar, y educación de los padres.








































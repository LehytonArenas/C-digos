---
title: "Determinantes del Ingreso"
author: "Lehyton Arenas"
date: "12/21/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Resumen de estadísticos descriptivos
En la siguiente tabla se encuentra el resúmen estadístico para el año 2017. La tabla contiene en las columnas los estadísticos de: cuantil al 25%, mediana, cuantil al 75%, media y desviación estandar; mientras que en cada fila se encuentra cada una de las variables disponibles en la data construida. Evidentemente todas estas variables son cuantitativas, algunas de orden dummy y otras de orden continuo. Tal y como se puede evidenciar a continuación.
```{r Procesamiento de Data, echo=FALSE}
# Evitemos la notación científica:
options(scipen=999)
# Para volver a notación cientifica:
options(scipen=0)

# Librerias
library(readxl)
library(tidyverse)
library(plyr); library(dplyr)
library(survey)
library(jtools)
library(stargazer)

# Data previamente procesada:
DataAnio_2017 <- read_excel("/Volumes/Respaldo/Google Drive-Actualizado/Ecsim/Proyecto Agosto/3_Entregables Lehyton/Data/DataAnio_2017_v3.xlsx")
DataAnio_2018 <- read_excel("/Volumes/Respaldo/Google Drive-Actualizado/Ecsim/Proyecto Agosto/3_Entregables Lehyton/Data/DataAnio_2018_v3.xlsx")
DataAnio_2019 <- read_excel("/Volumes/Respaldo/Google Drive-Actualizado/Ecsim/Proyecto Agosto/3_Entregables Lehyton/Data/DataAnio_2019_v3.xlsx")

# El objetivo es crear un solo DF para todos los años.
# Debemos renombrar algunas variables en cada DF, así:
DataAnio_2017 <- DataAnio_2017 %>% 
  dplyr::rename(AutonomiaFiscal="AutonomiaFiscal_2018_base2017",
                CapacidadRecaudo="CapacidadRecaudo_2018_base2017", 
                Homicidios="Homicidios_2018_base2018",
                Hurtos="Hurtos_2018_base2018",
                Extorsion="Extorsion_2018_base2018",
                EficJusticia="EficJusticia_2018_base2017",      
                ProducJueces="ProducJueces_2018_base2017",
                FacilidadEmpresa= "FacilidadEmpresa_2018",          
                ImpuestosEmpresa="ImpuestosEmpresa_2018",
                Desempleo_ICC="Desempleo_2018",                  
                ComplejidadProductiva="ComplejidadProductiva_2018",
                DiversifCanasta= "DiversifCanasta_2018_base2018",   
                Desempleo_Dane="Desempleo_2017_Dane",
                Poblacion_Dane="Poblacion_2017_Dane",             
                PIB_PC="PIB_PC2017_Dane")

DataAnio_2018 <- DataAnio_2018 %>% 
  dplyr::rename(AutonomiaFiscal="AutonomiaFiscal_2019_base2017",
                CapacidadRecaudo="CapacidadRecaudo_2019_base2018", 
                Homicidios="Homicidios_2019_base2019",
                Hurtos="Hurtos_2019_base2019",
                Extorsion="Extorsion_2019_base2019",
                EficJusticia="EficJusticia_2019_base2019",      
                ProducJueces="ProducJueces_2019_base2019",
                FacilidadEmpresa= "FacilidadEmpresa_2019",          
                ImpuestosEmpresa="ImpuestosEmpresa_2019",
                Desempleo_ICC="Desempleo_2019",                  
                ComplejidadProductiva="ComplejidadProductiva_2019",
                DiversifCanasta= "DiversifCanasta_2019_base2019",   
                Desempleo_Dane="Desempleo_2018_Dane",
                Poblacion_Dane="Poblacion_2018_Dane",             
                PIB_PC="PIB_PC2018_Dane")

DataAnio_2019 <- DataAnio_2019 %>% 
  dplyr::rename(AutonomiaFiscal="AutonomiaFiscal_2020_base2018",
                CapacidadRecaudo="CapacidadRecaudo_2020_base2018", 
                Homicidios="Homicidios_2020_base2019",
                Hurtos="Hurtos_2020_base2019",
                Extorsion="Extorsion_2020_base2019",
                EficJusticia="EficJusticia_2020_base2019",      
                ProducJueces="ProducJueces_2020_base2019",
                FacilidadEmpresa= "FacilidadEmpresa_2020",          
                ImpuestosEmpresa="ImpuestosEmpresa_2020",
                Desempleo_ICC="Desempleo_2020",                  
                ComplejidadProductiva="ComplejidadProductiva_2020",
                DiversifCanasta= "DiversifCanasta_2020_base2019",   
                Desempleo_Dane="Desempleo_2019_Dane",
                Poblacion_Dane="Poblacion_2019_Dane",             
                PIB_PC="PIB_PC2019_Dane")

# Concatenamos toda la data en un solo DF
DataAnio <- rbind(DataAnio_2017,DataAnio_2018,DataAnio_2019)

# Filtraremos por adultos
Adultos <- DataAnio %>% 
  filter(Edad>=18)
```

```{r Descriptivos con Survey Package, echo=FALSE}
# Data 2017

# Adultos
Adultos_2017 <- DataAnio_2017 %>% 
  filter(Edad>=18)

# dividimos el Fex en 12:
Adultos_2017 <- Adultos_2017 %>% 
  mutate(FExp=fex_c_2011/12) %>% 
  select(.,-c(fex_c_2011))

# Aplicamos el Survey:
AdutosSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=Adultos_2017)

# Medias: Aplicamos svymean a cada variable.
# Se hace una a una, de lo contrario los valores cambiarán debido a la eliminación causada por na.rm=T
# Haremos tres vbles a modo de prueba para 2017, en caso de más se puede intentar un FOR.
# Se apilan en un DF y se eliminan Means individuales
MeanSexo <- data.frame(svymean(~Sexo, AdutosSvy_2017, na.rm=T)) %>% 
  select(.,c("mean"))
MeanEdad <- data.frame(svymean(~Edad, AdutosSvy_2017, na.rm=T)) %>% 
  select(.,c("mean"))
MeanNivelEducativo <- data.frame(svymean(~NivelEducativo, AdutosSvy_2017,
                                         na.rm=T)) %>% 
  select(.,c("mean"))

Means_2017 <- rbind(MeanSexo,MeanEdad,MeanNivelEducativo) %>% 
  dplyr::rename(.,Mean=mean)
rm(MeanSexo,MeanEdad,MeanNivelEducativo)

# SD: Se aplica Svysd a cada variable.
# Se aplica el mismo procedimiento que en Means explicado anteriormente
SD_Sexo <- svysd(~Sexo,design = AdutosSvy_2017, na.rm = TRUE)
SD_Edad <- svysd(~Edad,design = AdutosSvy_2017, na.rm = TRUE)
SD_NivelEducativo <- svysd(~NivelEducativo,design = AdutosSvy_2017, 
                           na.rm = TRUE)
SD_2017 <- data.frame(rbind(SD_Sexo,SD_Edad,SD_NivelEducativo)) %>% 
  dplyr::rename(.,SD = "Sexo")
rm(SD_Sexo,SD_Edad,SD_NivelEducativo)

# Cuartiles: Se encuentran con svyquantile
# Se aplica el mismo procedimiento que en Means explicado anteriormente
Q_Sexo <- data.frame(svyquantile(~Sexo, design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_Edad <- data.frame(svyquantile(~Edad, design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_NivelEducativo <- data.frame(svyquantile(~NivelEducativo, 
                                           design =AdutosSvy_2017, na = TRUE,
                                 c(.25,.5,.75))) %>% 
  dplyr::rename(.,Q25="X0.25",Median="X0.5",Q75="X0.75")
Q_2017 <- data.frame(rbind(Q_Sexo,Q_Edad,Q_NivelEducativo))
rm(Q_Sexo,Q_Edad,Q_NivelEducativo)

# Se apila todo en un solo DF y se eliminan los anteriores pasos
Descriptivos_2017 <- cbind(Q_2017,Means_2017,SD_2017)
rm(Q_2017,Means_2017,SD_2017)

knitr::kable(
  Descriptivos_2017,
  caption = "Resumen estadístico Año 2017"
)
```

## Estadísticas por ciudad
La data recopilada se ha agrupado por ciudad y se han encontrado algunos resultados que vale la pena exponer. Es interesante observar como el ingreso medio de la población denominada Autoempleada es sustancialmente inferior a los ingresos medios de la ciudad; mientras que la población denominada Generadores de empleo exponen ingresos medios sustancialmente superiores.
```{r Estadísticas por Ciudad con Survey, echo=FALSE}
# Se puede mejorar con los subgrupos explicados en el Seminario (Justo antes de modelos)
# Solo se hace para Medellin en 2017.
# En caso de mas se puede crear una función.

# Primero debemos filtrar por ciudad: Población Gral, Autoempleados y Generadores.
# Aplicamos el survey correspondiente
Medellin_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin")
MedellinSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=Medellin_2017)

MedellinAutoem_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin"& Autoempleado==1)
MedellinAutoSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=MedellinAutoem_2017)

MedellinGener_2017 <- Adultos_2017 %>% 
  dplyr::filter(AREA=="Medellin"& GeneradorEmpleo==1)
MedellinGenerSvy_2017 <- svydesign(ids=~0,weights=~FExp,
                                  data=MedellinGener_2017)

# Se sacan las medias correspondientes, recordar que es una a una.
# Se apilan en un solo DF.
# se eliminan intermedios
Medellin_MeanEduca <- data.frame(svymean(~AniosEscolaridad, 
                                         MedellinSvy_2017, na.rm=T)) %>%
                          select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngreso <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngAuto <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinAutoSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_MeanIngGener <- data.frame(svymean(~IngresoLaboral_Mes, 
                                         MedellinGenerSvy_2017, na.rm=T)) %>% 
  select(.,c("mean")) %>% 
  dplyr::rename(.,Medellin="mean")

Medellin_Means <- data.frame(t(rbind(Medellin_MeanEduca,
                                            Medellin_MeanIngreso,
                                 Medellin_MeanIngAuto,
                                 Medellin_MeanIngGener))) %>% 
  dplyr::rename(.,"Años de escolaridad"="AniosEscolaridad",
                "Ingreso"="IngresoLaboral_Mes",
                "Ingreso de Autoempleadores"="IngresoLaboral_Mes1",
                "Ingreso de Generadores"="IngresoLaboral_Mes2")

rm(Medellin_2017,MedellinSvy_2017,MedellinAutoem_2017,MedellinAutoSvy_2017,
   MedellinGener_2017,MedellinGenerSvy_2017,Medellin_MeanEduca,
   Medellin_MeanIngreso,Medellin_MeanIngAuto,Medellin_MeanIngGener)

# Creamos la tabla.
knitr::kable(
  Medellin_Means,
  caption = "Estadísticas Ciudad Año 2017"
)
```

## Modelos

Recordemos que el modelo se desarrollará en tres etapas:

Etapa 1: 
Esta etapa busca encontrar la probabilidad de que un individuo sea Generador de empleo o Autoempleado. Por lo cual se harán dos estimaciones.
Variable dependiente: Se usarán las varibles dicotomicas de Generador de empleo y Autoempleado, respectivamente.
variables independientes: Se emplearán aquí las características socioeconómicas. Especificamente se usarán las variables de Ciudad impuestos, Ciudad apoyo al emprendimiento, Ciudad exportación de tecnologías.
Controles: Se emplearán aquí las características institucionales (o individules?). Estas son: Sexo, Edad, Posesión de TICs, Carga económica, Ciudad: PIB PC, y, Ciudad: Desempleo

Etapa 2: Aquí se estimará el ingreso del individuo empresario
Variable dependiente: Ingreso del individuo empresario.
Variables independientes: La probabilidad estimada en la etapa1, el sector económico, nivel educativo, experiencia potencial.
Controles: Se usarán aquí características institucionales. Es decir variables asociadas con el capital financiero, Ciudad:tamaño(población), Ciudad: tasa de delicuencia.
```{r Correlación de vbles, echo=FALSE}
# Correlaciones entre las variables del modelo continuo:
Data_Corr_ModCont <- Adultos_2017 %>% 
  dplyr::select(c("IngresoLaboral_Mes","AniosEscolaridad","NivelEducativo","ExperienciaPotencial","CapFinanciero_Mes","CapFinanciero_Anio","Poblacion_2017_Dane","Homicidios_2018_base2018","Hurtos_2018_base2018","Extorsion_2018_base2018","EficJusticia_2018_base2017","ProducJueces_2018_base2017","Sector_NR","Sector_Agricultura","Sector_Pesca","Sector_Minas","Sector_Industria","Sector_Electricidad","Sector_Comercio","Sector_Educacion","Sector_Transporte","Sector_Financiero","Sector_Construccion","Sector_Administracion","Sector_Extraterritorial","Sector_Inmobiliario","Sector_Salud","Sector_Hotel","Sector_Comunitario","Sector_Domestico"))

Corr_ModCont <- round(cor(Data_Corr_ModCont,use = "pairwise.complete.obs"),3)

# Correlaciones entre variables del modelo discreto:
# Usando la variable de Autoempleados
Data_Corr_ModDisc <- Adultos_2017 %>% 
  dplyr::select(c("Autoempleado","AutonomiaFiscal_2018_base2017","CapacidadRecaudo_2018_base2017","FacilidadEmpresa_2018","ImpuestosEmpresa_2018","ComplejidadProductiva_2018", "DiversifCanasta_2018_base2018","Sexo","Edad","PosesionComputador","PosesionInternet","CargaEconomica","PIB_PC2017_Dane","Desempleo_2018","Desempleo_2017_Dane"))

Corr_ModDisc <- round(cor(Data_Corr_ModDisc,use = "pairwise.complete.obs"),3)

# Usando la variable de Autoempleados
Data_Corr_ModDisc2 <- Adultos_2017 %>% 
  dplyr::select(c("GeneradorEmpleo","AutonomiaFiscal_2018_base2017","CapacidadRecaudo_2018_base2017","FacilidadEmpresa_2018","ImpuestosEmpresa_2018","ComplejidadProductiva_2018", "DiversifCanasta_2018_base2018","Sexo","Edad","PosesionComputador","PosesionInternet","CargaEconomica","PIB_PC2017_Dane","Desempleo_2018","Desempleo_2017_Dane"))

Corr_ModDisc2 <- round(cor(Data_Corr_ModDisc2,use = "pairwise.complete.obs"),3)
```
A continuación se realizarán algunas pruebas de los modelos simultaneos para la popblación de Autoempleados y Generadores:
```{r Etapas 1y2 Simultaneas, echo=FALSE}
# Creamos la edad cuadratica, como varriable alternativa de Edad:
Adultos <- Adultos %>% 
  dplyr::mutate(EdadCuadratica=round(Edad^2,2))

# Técnica de 2spls:
tspls <- function(formula1, formula2, data) {
    # The Continous model
    mf1 <- model.frame(formula1, data)
    y1 <- model.response(mf1)
    x1 <- model.matrix(attr(mf1, "terms"), mf1)

    # The dicontionous model
    mf2 <- model.frame(formula2, data)
    y2 <- model.response(mf2)
    x2 <- model.matrix(attr(mf2, "terms"), mf2)

    # The matrix of all the exogenous variables
    X <- cbind(x1, x2)
    X <- X[, unique(colnames(X))]

    J1 <- matrix(0, nrow = ncol(X), ncol = ncol(x1))
    J2 <- matrix(0, nrow = ncol(X), ncol = ncol(x2))
    for (i in 1:ncol(x1)) J1[match(colnames(x1)[i], colnames(X)), i] <- 1
    for (i in 1:ncol(x2)) J2[match(colnames(x2)[i], colnames(X)), i] <- 1

    # Step 1:
    #cat("\n\tNOW THE FIRST STAGE REGRESSION")
    m1 <- lm(y1 ~ X - 1)
    m2 <- glm(y2 ~ X - 1, family = binomial(link = "probit"))
    #print(summary(m1))
    #print(summary(m2))

    yhat1 <- m1$fitted.values
    yhat2 <- X %*% coef(m2)

    PI1 <- m1$coefficients
    PI2 <- m2$coefficients
    V0 <- vcov(m2)
    sigma1sq <- sum(m1$residuals ^ 2) / m1$df.residual
    sigma12 <- 1 / length(y2) * sum(y2 * m1$residuals / dnorm(yhat2))

    # Step 2:
    #cat("\n\tNOW THE SECOND STAGE REGRESSION WITH INSTRUMENTS")

    m1 <- lm(y1 ~ yhat2 + x1 - 1)
    m2 <- glm(y2 ~ yhat1 + x2 - 1, family = binomial(link = "probit"))
    sm1 <- summary(m1)
    sm2 <- summary(m2)
    #print(sm1)
    #print(sm2)

    # Step  3:
    cat("\tNOW THE SECOND STAGE REGRESSION WITH CORRECTED STANDARD ERRORS\n\n")
    gamma1 <- m1$coefficients[1]
    gamma2 <- m2$coefficients[1]

    cc <- sigma1sq - 2 * gamma1 * sigma12
    dd <- gamma2 ^ 2 * sigma1sq - 2 * gamma2 * sigma12
    H <- cbind(PI2, J1)
    G <- cbind(PI1, J2)

    XX <- crossprod(X)                          # X'X
    HXXH <- solve(t(H) %*% XX %*% H)            # (H'X'XH)^(-1)
    HXXVXXH <- t(H) %*% XX %*% V0 %*% XX %*% H  # H'X'V0X'XH
    Valpha1 <- cc * HXXH + gamma1 ^ 2 * HXXH %*% HXXVXXH %*% HXXH

    GV <- t(G) %*% solve(V0)    # G'V0^(-1)
    GVG <- solve(GV %*% G)      # (G'V0^(-1)G)^(-1)
    Valpha2 <- GVG + dd * GVG %*% GV %*% solve(XX) %*% solve(V0) %*% G %*% GVG

    ans1 <- coef(sm1)
    ans2 <- coef(sm2)

    ans1[,2] <- sqrt(diag(Valpha1))
    ans2[,2] <- sqrt(diag(Valpha2))
    ans1[,3] <- (ans1[,1] / ans1[,2])
    ans2[,3] <- (ans2[,1] / ans2[,2])
    ans1[,4] <- 2 * pt(abs(ans1[,3]), m1$df.residual, lower.tail = FALSE)
    ans2[,4] <- 2 * pnorm(abs(ans2[,3]), lower.tail = FALSE)

    cat("Continuous:\n")
    print(ans1)
    cat("Dichotomous:\n")
    print(ans2)
    return(c(ans1,ans2))
}

# Para Data completa:

# GeneradorEmpleo:
Data_Prueba <- Adultos %>% 
  dplyr::select(c("IngresoLaboral_Mes","NivelEducativo","ExperienciaPotencial","Poblacion_Dane","Homicidios","Sector_Agricultura","Sector_Pesca","Sector_Minas","Sector_Industria","Sector_Electricidad","Sector_Comercio","Sector_Educacion","Sector_Transporte","Sector_Financiero","Sector_Construccion","Sector_Administracion","Sector_Extraterritorial","Sector_Inmobiliario","Sector_Salud","Sector_Hotel","Sector_Comunitario",
                  "GeneradorEmpleo","AutonomiaFiscal","CargaEconomica","Sexo","Edad","PosesionComputador","Desempleo_Dane")) %>% 
  drop_na(.)

tspls(IngresoLaboral_Mes~NivelEducativo+ExperienciaPotencial+Poblacion_Dane+Homicidios+Sector_Agricultura+Sector_Pesca+Sector_Minas+Sector_Industria+Sector_Electricidad+Sector_Comercio+Sector_Educacion+Sector_Transporte+Sector_Financiero+Sector_Construccion+Sector_Administracion+Sector_Extraterritorial+Sector_Inmobiliario+Sector_Salud+Sector_Hotel+Sector_Comunitario,
     GeneradorEmpleo~AutonomiaFiscal+CargaEconomica+Sexo+Edad+PosesionComputador+Desempleo_Dane,
    data = Data_Prueba)

# Autoempleado:
Data_Prueba <- Adultos %>% 
  dplyr::select(c("IngresoLaboral_Mes","NivelEducativo","ExperienciaPotencial","Poblacion_Dane","Homicidios","Sector_Agricultura","Sector_Pesca","Sector_Minas","Sector_Industria","Sector_Electricidad","Sector_Comercio","Sector_Educacion","Sector_Transporte","Sector_Financiero","Sector_Construccion","Sector_Administracion","Sector_Extraterritorial","Sector_Inmobiliario","Sector_Salud","Sector_Hotel","Sector_Comunitario",
                  "Autoempleado","AutonomiaFiscal","CargaEconomica","Sexo","Edad","PosesionComputador","Desempleo_Dane")) %>% 
  drop_na(.)

tspls(IngresoLaboral_Mes~NivelEducativo+ExperienciaPotencial+Poblacion_Dane+Homicidios+Sector_Agricultura+Sector_Pesca+Sector_Minas+Sector_Industria+Sector_Electricidad+Sector_Comercio+Sector_Educacion+Sector_Transporte+Sector_Financiero+Sector_Construccion+Sector_Administracion+Sector_Extraterritorial+Sector_Inmobiliario+Sector_Salud+Sector_Hotel+Sector_Comunitario,
     Autoempleado~AutonomiaFiscal+CargaEconomica+Sexo+Edad+PosesionComputador+Desempleo_Dane,
    data = Data_Prueba)
```

Etapa 3: Aquí se estimará el ingreso del hogar del empresario.
Variable dependiente: Ingreso del hogar del individuo empresario.
Variable independiente: Se usará el ingreso del individuo empresario estimado en la etapa 1.
Controles: Se usarán controles por familias. Específicamente variables de Parentesco con Jefe de hogar, Estado Civil, Situación laboral, Transferencias o subsidios, posesión de viviendda, # de niños menores a 14 años, # Personas en el hogar, y educación de los padres.
Debido a los cambios del proyecto. Esta etapa requerirá del procesamiento de data.
```{r Etapa 3 Procesamiento Data, echo=FALSE}
# Primero crearemos los INgresos de Generadores y Autoempleados con una media simple.
# Traemos  la data procesada previamente en v0: 2017, 2018 y 2019:
# Esta data es útil porque los sectores son factores, no dummies
DataAnio_2019_v0 <- read_excel("/Volumes/Respaldo/Google Drive-Actualizado/Ecsim/Proyecto Agosto/3_Entregables Lehyton/Data/DataAnio_2019.xlsx")

# Se deben codificar las areas:
DataAnio_2019_v0 <- DataAnio_2019_v0 %>%
  dplyr::mutate(AREA=ifelse(AREA==5,"Medellin",AREA),
                AREA=ifelse(AREA==8,"Barranquilla",AREA),
                AREA=ifelse(AREA==11,"Bogota DC",AREA),
                AREA=ifelse(AREA==13,"Cartagena",AREA),
                AREA=ifelse(AREA==17,"Manizales",AREA),
                AREA=ifelse(AREA==23,"Monteria",AREA),
                AREA=ifelse(AREA==50,"Villavicencio",AREA),
                AREA=ifelse(AREA==52,"Pasto",AREA),
                AREA=ifelse(AREA==54,"Cucuta",AREA),
                AREA=ifelse(AREA==66,"Pereira",AREA),
                AREA=ifelse(AREA==68,"Bucaramanga",AREA),
                AREA=ifelse(AREA==73,"Ibague",AREA),
                AREA=ifelse(AREA==76,"Cali",AREA))

#Primero creemos promedios simples:

# Debemos crear una variable por año:
DataAnio_2017_v0$Anio <- c("2017")
DataAnio_2018_v0$Anio <- c("2018")
DataAnio_2019_v0$Anio <- c("2019")

# Se crea una solo DFv0:
DataAnio_v0 <- rbind(DataAnio_2017_v0,DataAnio_2018_v0,DataAnio_2019_v0)

# Creamos los Ingresos de Generadores:
IngresosGeneradores_Anio <- DataAnio_v0 %>% 
    dplyr::filter(Generadores_Empleo=="Generador de empleo") %>% 
    dplyr::group_by(Anio, AREA, SectorEconomico) %>%
    dplyr::summarise(
      IngresosGeneradores_Simple = mean(IngresoLaboral_Mes,na.rm = TRUE)
      )
# Creamos los Ingresos de Autoempleados:
IngresosAutoempleados_Anio <- DataAnio_v0 %>% 
    dplyr::filter(Generadores_Empleo=="Autoempleado") %>% 
    dplyr::group_by(Anio, AREA, SectorEconomico) %>%
    dplyr::summarise(
      IngresosAutoempleados_Simple = mean(IngresoLaboral_Mes,na.rm = TRUE)
      )

# Se concatena:
Ingresos_Simples <- join_all(list(IngresosGeneradores_Anio,IngresosAutoempleados_Anio),
                             by=c("Anio","AREA","SectorEconomico"),type = "full")

# Ahora, creamos promedios con Survey (factor de expansión):
# Transformamos la data a tipo Survey:
# dividimos el Fex en 12:
DataAnio_v0 <- DataAnio_v0 %>% 
  mutate(FExp=fex_c_2011/12) %>% 
  select(.,-c(fex_c_2011))

# Creamos la población de Generadores:
GeneradoresAnio <- DataAnio_v0 %>% 
  dplyr::filter(Generadores_Empleo=="Generador de empleo")

GeneradoresAnio_Svy <- svydesign(ids=~0,weights=~FExp,
                                  data=GeneradoresAnio)

# Ahora apliquemos la media agrupando con svyby:

MeansGeneradores_Svy <- svyby(~IngresoLaboral_Mes, ~Anio+AREA+SectorEconomico, 
      GeneradoresAnio_Svy, svymean,na = TRUE)

# Aplicamos lo mismo para los Autoempleados. 
# Creamos la población de autoempleados:
AutoempleadosAnio <- DataAnio_v0 %>% 
  dplyr::filter(Generadores_Empleo=="Autoempleado")

AutoempleadosAnio_Svy <- svydesign(ids=~0,weights=~FExp,
                                  data=AutoempleadosAnio)

# Ahora apliquemos la media agrupando con svyby:
MeansAutoempleados_Svy <- svyby(~IngresoLaboral_Mes, ~Anio+AREA+SectorEconomico, 
      AutoempleadosAnio_Svy, svymean,na = TRUE)

# Aplicamos unas modificaciones a ambos DF:
MeansGeneradores_Svy <- MeansGeneradores_Svy %>% 
  select(.,-c(se)) %>% 
  dplyr::rename(IngresosGeneradores_Svy="IngresoLaboral_Mes")

MeansAutoempleados_Svy <- MeansAutoempleados_Svy %>% 
  select(.,-c(se)) %>% 
  dplyr::rename(IngresosAutoempleados_Svy="IngresoLaboral_Mes")

# Se concatena:
Ingresos_Svy <- join_all(list(MeansGeneradores_Svy,MeansAutoempleados_Svy),
                             by=c("Anio","AREA","SectorEconomico"),type = "full")

# Cambiamos los 0 por NA:
Ingresos_Svy <- Ingresos_Svy %>%
  dplyr::mutate(IngresosGeneradores_Svy=ifelse(IngresosGeneradores_Svy==0,NA,
                                         IngresosGeneradores_Svy),
                IngresosAutoempleados_Svy=ifelse(IngresosAutoempleados_Svy==0,NA,
                                         IngresosAutoempleados_Svy))

# PLT ahora tenemos dos DF de Ingresos: Uno Simple y uno con Survey. Ingresos_Simples e Ingresos_Svy. Se eliminan intermedios.
```






































